---
layout: post
title: 'Course review: SQL Performance'
date: '2015-01-14T21:30:00.002+01:00'
author: Sakis Kasampallis
tags:
- course
- MySQL
- performance
- review
- book
- sql
modified_time: '2015-01-25T00:25:01.763+01:00'
blogger_id: tag:blogger.com,1999:blog-7146248794813174249.post-4867427469055446630
blogger_orig_url: http://sakiskasampalis.blogspot.com/2015/01/course-review-sql-performance.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><b>Update:</b> Markus was kind enough to comment on my review. Regarding the "minimise the number of tables to limit joins" he said:<br /><blockquote class="tr_bq"><span style="font-family: Helvetica; font-size: 12px;">it is often the best approach to store some attribute redundant (e.g.&nbsp;</span><span style="font-family: Helvetica;"><span style="font-size: 12px;">normalised&nbsp;as before plus wherever needed). Maintenance of this&nbsp;</span></span><span style="font-family: Helvetica; font-size: 12px;">redundancy should be delegated to the database whenever possible (e.g.&nbsp;</span><span style="font-family: Helvetica;"><span style="font-size: 12px;">using triggers or&nbsp;materialised&nbsp;view). You should not do that before&nbsp;having those performance problems (avoid "premature&nbsp;optimisation").</span></span><span style="font-family: Helvetica; font-size: 12px;">Reducing the number of joins is a good way to get performance. But only once you are in that situation. And of course, there are other, simpler ways to improve performance that should be leveraged first (e.g, good-old indexing).</span></blockquote>So I'm glad that we agree that normalisation is a good thing and that we should only try to find alternative solutions if nothing else (e.g. proper indexing) works.<br /><br />Markus also made an important comment about the column order in the WHERE clause that is not clarified in my original post:<br /><blockquote class="tr_bq"><ul style="text-align: left;"><li><span style="font-family: Helvetica; font-size: 12px;">The column order in indexes matters a lot</span>&nbsp;</li></ul></blockquote><blockquote class="tr_bq"><ul style="text-align: left;"><li><span style="font-family: Helvetica; font-size: 12px;">The column order in the WHERE clause doesn't matter (rare exceptions exist, but generally, it doesn't!).</span></li></ul></blockquote><br /><br />The original post starts here...<br /><br />Last <strike>October</strike>&nbsp;November I followed a course related to the performance of SQL. The course was given by <a href="http://use-the-index-luke.com/">Markus Winand</a>. Although we don't agree on everything (for example I don't like the "create as few tables as possible to minimise joins and achieve better performance" principle because it is against normalisation) Markus has a great knowledge of general and RDBMS-specific performance related issues.<br /><br />I'm glad that I followed this course. Markus gave us a copy of <a href="http://sql-performance-explained.com/?utm_source=UTIL&amp;utm_medium=main&amp;utm_campaign=second">his book</a> which is very compact and to the point. This is an example of a book that I would never consider reading but it turns out to be a hidden gem. I recommend it to everyone working with relational databases.<br /><br />It took me some time to write this post because I wanted to read the book first. In this book you will find things that you don't know for sure. For example, did you know that:<br /><ul style="text-align: left;"><li>When building indexes on more than one columns (concatenated indexes), the order of the columns matters a lot?</li><li>The order of the statements in the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">WHERE</span> part of a query affects whether a concatenated index is used or not?</li><li><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">LIKE</span> expressions with leading wildcards (eg. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">'%SQL'</span>) cannot make use of an index?</li><li>ORMs can cause big performance problems because of the bad queries that they generate?</li><li>Selecting only the necessary columns (avoid <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT *</span>) can improve the performance of joins?</li><li>An index that covers all the columns of an SQL query (including the columns of the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT</span> part) does not need to access any other data structures except the index and improves the performance of a query enormously?</li><li><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ORDER BY</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">GROUP BY</span> can also be indexed?</li></ul><br />The main message of the book is that indexes should be built by us, the developers, not by DBAs or anyone else. That's because only we know how the data are queried, and therefore only we can build the proper indexes.<br /><br />Personally, I'm very sad to see how many features that are supported by other RDBMS are not supported by MySQL. To mention a few: indexing functions and expressions, partial indexes, indexing using <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ASC</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">DESC</span>, window functions. Fortunately, MariaDB is getting there and I hope that we'll switch to it (at work) at some point.</div>