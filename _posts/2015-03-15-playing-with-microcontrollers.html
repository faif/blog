---
layout: post
title: Playing with microcontrollers
date: '2015-03-15T18:35:00.002+01:00'
author: Sakis Kasampallis
tags:
- arm
- mbed
- course
- programming
- microcontroller
- review
- embedded system
- LPC1768
modified_time: '2015-03-15T18:35:14.932+01:00'
blogger_id: tag:blogger.com,1999:blog-7146248794813174249.post-6578036855194883176
blogger_orig_url: http://sakiskasampalis.blogspot.com/2015/03/playing-with-microcontrollers.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">The last training course that I followed was about programming microcontrollers. The course was given by Leon van Snippenberg, who has very good expertise in microcontrollers.<br /><br />For the practical part of the course we used the Microchip dsPIC33F, a 16-bit architecture 40 MHZ microcontroller (system on a chip solution). I admit that I'm not very fond of this proprietary platform, so I enjoyed the theoretical part of the course much more than the practical. I would be more excited if we have used an open hardware solution like arduino, Raspberry Pi, or something comparable.<br /><br />A few highlights from the course:<br /><ul style="text-align: left;"><li>A three-operand assembly instruction does not necessarily mean that three registers are used. For example <span style="font-family: Courier New, Courier, monospace;">ADD W0, W1, W0</span> uses only one register.</li><li>Most microcontrollers use the Harvard instead of the&nbsp;<span style="color: #252525; font-family: sans-serif; font-size: 14px; line-height: 22px;">Von Neumann</span>&nbsp;architecture. This means that there are two distinct address buses, as well as two data buses (instead of one address and one data bus).</li><li>When writing code in assembly we should avoid thinking about code optimisation, since the code is usually very fast to execute (but very slow to produce).</li><li>A common problem when programming microcontrollers is <a href="http://www.piclist.com/techref/readmodwrite.htm">read-modify-write</a>. One way to solve it is using shadow registers.</li><li>When programming a microcontroller using a C interface and interrupts, it is very important to use the <span style="font-family: Courier New, Courier, monospace;">volatile</span> keyword to disable optimisations that might remove code that seems to be dead but is actually used. Because of that, it is also very important to test the code with all compiler optimisation levels enabled, to ensure that it doesn't break.</li><li>The hardware timers of a platform do not need to follow the same architecture with the processor. For example a platform might use a 16-bit processor with 32-bit timers.</li><li>Buffers and interrupts are used to solve communication problems between different devices (e.g. a computer communicating with a microcontroller using the serial port).</li><li>When dealing with non-deterministic problems, disabling interrupts is the most favoured solution.</li><li>Using a real-time operating system (RTOS) simplifies programming, because we avoid the need to write complex state machines and custom schedulers (those problems are already solved in the RTOS).</li><li>Multicore support in RTOS is a challenge (unsolved problem?).</li></ul><div><br /></div><div>We (me and my colleague) challenged Leon by questioning why would one prefer a much more expensive solution like the dsPIC* family of Microchip instead of Raspberry Pi or arduino. The price of the latest Pi is unbeatable. The response was that we should use whatever fits our purpose, and that the Pi manages to achieve such a low price because its makers can estimate in advance the minimum numbers of units that will be sold. Those manufacturing deals are critical in forming the end price of a prototyping platform.</div><div><br /></div><div><br /></div><div>So far I only own an mbed LPC1768 and I'm very satisfied with it. I hope that I'll build some more advanced prototypes in the future, but you have to start from something. I began with flashing LEDs<br /><br /></div><div><iframe allowfullscreen="" frameborder="0" height="889" mozallowfullscreen="" src="https://player.vimeo.com/video/120307094" webkitallowfullscreen="" width="500"></iframe><br /><br /><br />Continued with adding some basic components like a button<br /><br /><iframe allowfullscreen="" frameborder="0" height="889" mozallowfullscreen="" src="https://player.vimeo.com/video/120957456" webkitallowfullscreen="" width="500"></iframe></div><div><br /><br />And at some point I built my first practical prototype: a darkness-activated LED<br /><br /></div><iframe allowfullscreen="" frameborder="0" height="889" mozallowfullscreen="" src="https://player.vimeo.com/video/120970019" webkitallowfullscreen="" width="500"></iframe> <br />Isn't that nice? In my future posts the plan is to spend more time on explaining the code of prototypes like the last one. For now you can check my <a href="http://developer.mbed.org/users/faif/">mbed repository</a> page.</div>